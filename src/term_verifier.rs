/* [[INSERT: header]] */

/* [[IGNORE */
mod term_verifier {
/* IGNORE]] */
extern crate chrono;
extern crate regex;

use std::collections::HashMap;
use std::env;
use std::fmt;
use std::fmt::{Debug, Display};
use std::fs::File;
use std::iter;
use std::io::prelude::*;
use std::io::stdin;
use std::path::Path;

use chrono::DateTime;
use chrono::Utc;
use regex::Regex;

fn number_word(x: usize) -> &'static str {
    match x {
        0 => "zero",
        1 => "one",
        2 => "two",
        3 => "three",
        4 => "four",
        5 => "five",
        6 => "six",
        7 => "seven",
        8 => "eight",
        9 => "nine",
        _ => panic!(),
    }
}

fn char_has_case(c: char) -> bool {
    c.is_lowercase() || c.is_uppercase()
}

fn to_camel_case(s: &str) -> String {
    let re_split = Regex::new(r"[^a-zA-Z]+").unwrap();
    re_split.split(s)
            .map(|word| {
                word.chars().enumerate().map(|(i, c)| if i == 0 {
                    c.to_uppercase().collect::<String>()
                } else {
                    c.to_lowercase().collect()
                })
                .collect::<Vec<_>>()
                .concat()
            })
            .filter(|x| !x.is_empty())
            .collect::<Vec<_>>()
            .iter().fold((String::new(), None), |(acc, prev): (String, Option<&String>), next| {
                let join = if let Some(prev) = prev {
                                let l = prev.chars().last().unwrap();
                                let f = next.chars().next().unwrap();
                                !char_has_case(l) && !char_has_case(f)
                            } else { false };
                (acc + if join { "_" } else { "" } + next, Some(next))
            }).0
}

struct CoqGen<'a> {
    name: &'a str,
    ops: &'a Vec<(&'a str, Vec<u8>)>,
}

impl<'a> CoqGen<'a> {
    fn gen_colimit(&self) -> String {
        format!("{}{}\n{}", self.comment(), self.header(), self.body())
    }

    fn header(&self) -> String {
        format!("\
            {}\n\
            \n\
            Local Infix \"::\" := (@cons nat).\n\
            Local Notation \"[]\" := (@nil nat) (at level 0, format \"[]\").\n\
            Local Notation \"'HSET2'\":= [HSET, HSET, has_homsets_HSET].\n\
            \n\
            {}\
        ", self.imports(false), self.preamble())
    }

    fn comment(&self) -> String {
        let now: DateTime<Utc> = Utc::now();
        format!("\
            (* Autogenerated Coq file: {} *)\n\
            \n\
        ", now.format("%Y-%m-%d %H:%M:%S"))
    }

    fn preamble(&self) -> String {
        format!("\
            Local Open Scope cat.\n\
            \n\
            Section preamble.\n\
            \n\
            {}\n\
            Local Lemma has_homsets_HSET2 : has_homsets HSET2.\n\
            Proof.\n\t\
                apply functor_category_has_homsets.\n\
            Defined.\n\
            \n\
            End preamble.\
        ", self.n_rec())
    }

    fn n_rec(&self) -> String {
        const LETTERS: [&str; 9] = ["a", "b", "c", "d", "e", "f", "g", "h", "i"];
        let n = self.ops.len();
        let vars = &LETTERS[0..n as usize];
        let ind_steps: Vec<_> = vars.iter()
                                    .map(|v| format!("induction n as [|n _]; [apply {}|].", v))
                                    .collect();
        format!("\
            Definition {n}_rec {{A : UU}} ({} : A) : stn {} -> A.\n\
            Proof.\n\t\
            induction 1 as [n p].\n\t\
            {}\n\t\
            induction (nopathsfalsetotrue p).\n\
            Defined.\
        ", vars.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(" "),
        n,
        ind_steps.join("\n\t"),
        n = number_word(n))
    }

    fn imports(&self, conservative: bool) -> String {
        let required = format!("\
            Require Import UniMath.Foundations.PartD.\
        ");
        if conservative {
            required
        } else {
            format!("\
                {}
                \n\
                Require Import UniMath.Combinatorics.StandardFiniteSets.\n\
                Require Import UniMath.Combinatorics.Lists.\n\
                \n\
                Require Import UniMath.CategoryTheory.Categories.\n\
                Require Import UniMath.CategoryTheory.functor_categories.\n\
                Require Import UniMath.CategoryTheory.categories.category_hset.\n\
                Require Import UniMath.CategoryTheory.categories.category_hset_structures.\n\
                Require Import UniMath.CategoryTheory.limits.initial.\n\
                Require Import UniMath.CategoryTheory.FunctorAlgebras.\n\
                Require Import UniMath.CategoryTheory.Monads.Monads.\n\
                \n\
                Require Import UniMath.SubstitutionSystems.Signatures.\n\
                Require Import UniMath.SubstitutionSystems.BindingSigToMonad.\n\
                Require Import UniMath.SubstitutionSystems.LiftingInitial_alt.\
            ", required)
        }
    }

    fn body(&self) -> String {
        let names = self.ops.iter().map(|x| x.0.to_string()).collect::<Vec<_>>();
        let sigs = self.ops.iter().map(|x| format!("{:?}", x.1)).collect::<Vec<_>>();
        let definitions: Vec<String> = self.ops.iter().map(|&(ref name, ref sig)| {
            let sig = format!("({} :: [])",
                            sig.iter().map(u8::to_string).collect::<Vec<_>>().join(" :: "));
            format!("Local Definition {} := {}.", name, sig)
        }).collect();

        format!("\
            Section {code}.\n\
            \n\
            {}
            \n\
            (* The signature of {name}: {{ {} }} *)\n\
            Definition {code}Sig : BindingSig :=\n\t\
                mkBindingSig (isasetstn {}) ({n}_rec {}).\n\
            \n\
            (* The signature with strength for {name} *)\n\
            Definition {code}SigWithStr : Signature HSET has_homsets_HSET _ _ :=\n\t\
                BindingSigToSignatureHSET {code}Sig.\n\
            \n\
            Let Id_H := Id_H _ has_homsets_HSET BinCoproductsHSET.\n\
            \n\
            Definition {code}Functor : functor HSET2 HSET2 := Id_H {code}SigWithStr.\n\
            \n\
            Lemma {code}Functor_Initial : Initial (FunctorAlg {code}Functor has_homsets_HSET2).\n\
            Proof.\n\t\
                apply SignatureInitialAlgebraHSET, is_omega_cocont_BindingSigToSignatureHSET.\n\
            Defined.\n\
            \n\
            Definition {code}Monad : Monad HSET := BindingSigToMonadHSET {code}Sig.\n\
            \n\
            End {code}.\
        ", definitions.join("\n"),
        sigs.join(", "),
        self.ops.len(),
        names.join(" "),
        name = self.name,
        code = to_camel_case(self.name),
        n = number_word(self.ops.len()))
    }

    fn gen_inductive_type(&self, terms: Vec<String>) -> String {
        format!("{}{}\n\n{}\n\n{}",
                self.comment(),
                self.imports(true),
                self.inductive(),
                terms.join("\n\n"))
    }

    fn inductive(&self) -> String {
        let code = to_camel_case(self.name);
        let variants = self.ops.iter().map(|x| {
            format!("| {} : {}",
                    x.0,
                    iter::repeat(code.clone())
                         .take(x.1.len() + 1)
                         .collect::<Vec<_>>()
                         .join(" -> "))
        }).collect::<Vec<_>>().join("\n");
        format!("\
            Inductive {code} : UU :=\n\
            | var : nat -> nat -> {code}\n\
            {variants}.\
        ",
        code = code,
        variants = variants)
        // Check app (abs (var 0)) (abs (var 0)).
    }

    fn inductive_term(&self, term: Term) -> String {
        format!("\
            Check {}.\
        ", term)
    }
}

#[derive(Clone)]
struct ParseError {
    s: String,
    range: (usize, usize),
    error: String,
    hint: String,
}

impl Debug for ParseError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let hint = if self.hint.is_empty() {
            String::new()
        } else {
            format!("({})", self.hint)
        };
        let mut spaces = self.range.0;
        let (prehint, posthint): (&str, &str) = if spaces >= hint.len() + 1 {
            (&hint, "")
        } else {
            ("", &hint)
        };
        let space_offset = !prehint.is_empty() as usize;
        spaces -= prehint.len() + space_offset;
        write!(f,
            "\n{start}{} (L1:{}-{}):{end}\n{}\n{start}{}{prehint}{}{posthint}{end}\n",
            self.error,
            self.range.0,
            self.range.1,
            self.s,
            " ".repeat(spaces),
            (if prehint.is_empty() { String::new() } else { " ".to_string() })
                + &"^".repeat(self.range.1 - self.range.0),
            prehint = prehint,
            posthint = posthint,
            start = "\x1b[31;1m",
            end = "\x1b[0m")
    }
}

trait FailParse<T> {
    fn or_fail(self, error: &str) -> T;
}

impl<T> FailParse<T> for Result<T, ParseError> {
    fn or_fail(self, error: &str) -> T {
        if let Err(ref pe) = self {
            let mut pe = pe.clone();
            pe.error = error.to_string();
            Err::<T, _>(pe).expect(error)
        } else {
            self.unwrap()
        }
    }
}

struct Operation {
    op: String,
    args: Vec<Term>,
}

impl Display for Operation {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}{}", self.op, self.args.iter().map(|arg| {
            format!(" ({})", arg)
        }).collect::<Vec<_>>().join(""))
    }
}

enum Term {
    Var(u8, u8),
    Op(Operation)
}

impl Display for Term {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            &Term::Var(depth, offset) => write!(f, "var {} {}", depth, offset),
            &Term::Op(ref op) => op.fmt(f),
        }
    }
}

struct TermParser<'a> {
    os: String, // original string
    s: String, // current string
    pos: usize, // current position
    ops: &'a Vec<(&'a str, Vec<u8>)>, // valid operations
}

impl<'a> TermParser<'a> {
    fn error_hint(&self, hint: &str) -> ParseError {
        ParseError {
            s: self.os.clone(),
            range: (self.pos, self.pos + 1),
            error: String::new(),
            hint: hint.to_string(),
        }
    }

    fn error(&self) -> ParseError {
        self.error_hint("")
    }

    fn eat_op(&mut self, vars: HashMap<String, (u8, u8)>, level: u8)
        -> Result<Term, ParseError> {
        let name_result = self.eat_name();
        if let Err(e) = name_result {
            return if vars.len() > 0 {
                // TODO: Validate var
                let var = self.eat_var().or_fail("didn't find var");
                if let Some(&(level, offset)) = vars.get(&var) {
                    Ok(Term::Var(level, offset))
                } else {
                    panic!("var unbound");
                }
            } else {
                Err(e)
            }
        }
        let (name, arity) = name_result.or_fail("couldn't unwrap name_result");
        let mut args = vec![];
        for num_binders in arity {
            self.eat_space()?;
            args.push(self.eat_argument(num_binders, vars.clone(), level)
                          .or_fail("didn't find argument"));
        }
        Ok(Term::Op(Operation {
            op: name,
            args,
        }))
    }

    fn eat_str(&mut self, s: &str) -> Result<String, ParseError> {
        let re_str = Regex::new(&format!("^{}", s)).expect("invalid str for regex");
        let s = self.s.clone();
        if let Some(m) = re_str.find(&s) {
            self.s = re_str.replace(&self.s, "").to_string();
            let mstr = m.as_str().to_string();
            self.pos += mstr.len();
            return Ok(mstr);
        }
        Err(self.error())
    }

    fn eat_str_ignore(&mut self, s: &str) -> Result<(), ParseError> {
        self.eat_str(s)?;
        Ok(())
    }

    fn eat_space(&mut self) -> Result<(), ParseError> {
        self.eat_str_ignore(" ")
    }

    fn eat_open(&mut self) -> Result<(), ParseError> {
        self.eat_str_ignore(r"\(")
    }

    fn eat_close(&mut self) -> Result<(), ParseError> {
        self.eat_str_ignore(r"\)")
    }

    fn eat_name(&mut self) -> Result<(String, Vec<u8>), ParseError> {
        let re_name = Regex::new(r"^[a-z][a-z']+").unwrap();
        let s = self.s.clone();
        if let Some(name) = re_name.find(&s) {
            for &(ref on, ref oa) in self.ops {
                if *on == name.as_str() {
                    self.s = re_name.replace(&self.s, "").to_string();
                    self.pos += on.len();
                    return Ok((on.to_string(), oa.clone()));
                }
            }
        }
        Err(self.error())
    }

    fn eat_argument(&mut self,
                    binders: u8,
                    mut vars: HashMap<String, (u8, u8)>,
                    level: u8) -> Result<Term, ParseError> {
        self.eat_open().or_fail("didn't find `(`");
        for i in 0..binders {
            // TODO: Check validity of binders
            vars.insert(self.eat_var()?, (level, i));
            self.eat_space().or_fail("didn't find space");
        }
        if binders > 0 {
            let eat_arrow = self.eat_str("-> ");
            if let Err(_) = eat_arrow {
                if Regex::new(&format!("^>")).unwrap().is_match(&self.s) {
                    Err::<(), ParseError>(self.error_hint("you probably meant `->`"))
                        .or_fail("unexpected symbol `>`");
                } else {
                    eat_arrow.or_fail("didn't find arrow");
                }
            }
        }
        let op = self.eat_op(vars.clone(), level + 1).or_fail("didn't find op");
        self.eat_close().or_fail("didn't find `)`");
        Ok(op)
    }

    fn eat_var(&mut self) -> Result<String, ParseError> {
        Ok(self.eat_str("[a-z]+")?)
    }
}

// We only run `main` in the second stage of our pipeline, so it will be
// marked as unused by the compiler. We just want it to compile.
#[allow(dead_code)] /* [[IGNORE]] */
fn main() {
    let inferred_name: &str;
    inferred_name = "signatures"; /* [[INSERT: inferred_name]] */
    // Input
    let args: Vec<String> = env::args().collect();
    let filename = args.get(1).expect("pass a filename as an argument");
    let interactive = filename == "-i" || filename == "--interactive";
    let mut terms: Vec<String> = vec![];
    if !interactive {
        // Load terms from a file.
        let mut f = File::open(filename).expect("the file could not be found");
        let mut contents = String::new();
        f.read_to_string(&mut contents).expect("could not read the file");
        let lines = contents.split("\n");
        let re_comment = Regex::new(r"^#.*$").unwrap();
        terms = lines.filter_map(|s| {
            let s = s.trim();
            if s.is_empty() || re_comment.is_match(s) {
                return None;
            }
            Some(s.to_string())
        }).collect();
    }

    let ops: Vec<(&str, Vec<u8>)> = vec![
        /* [[INSERT: ops]] */
    ];

    let coq_gen = CoqGen { name: inferred_name, ops: &ops };

    let check_term = |term: String| {
        let mut term_parser = TermParser {
            os: term.clone(),
            s: term.clone(),
            pos: 0,
            ops: &ops
        };
        let vars: HashMap<String, (u8, u8)> = HashMap::new();
        let term = term_parser.eat_op(vars, 0).expect("term was not valid!");
        println!("Term was syntactically correct.");
        coq_gen.inductive_term(term)
    };

    let mut verified_terms = vec![];
    if interactive {
        // Interactive mode.
        loop {
            println!("Please enter a term to type check:");
            let mut term = String::new();
            let bytes = stdin().read_line(&mut term).expect("Error reading input string");
            if bytes == 0 {
                // EOF
                break;
            }
            term.pop(); // Remove \n
            verified_terms.push(check_term(term));
        }
    } else {
        for term in terms {
            verified_terms.push(check_term(term));
        }
    }

    // Output
    let output = format!("{}\n", coq_gen.gen_colimit());
    if false {
        println!();
        println!("{}", output);
    }
    // Substitution omega-colimit file
    let mut f = File::create(Path::new(&format!("out/{}-colimit", coq_gen.name))
                     .with_extension("v"))
                     .expect("could not create the generated Coq colimit file");
    write!(f, "{}", output).expect("could not write to the generated Coq colimit file");
    println!("Generated a construction of the colimit at: {}-colimit.v", coq_gen.name);
    // Inductive type file
    let output = format!("{}\n", coq_gen.gen_inductive_type(verified_terms));
    let mut f = File::create(Path::new(&format!("out/{}-indty", coq_gen.name))
                     .with_extension("v"))
                     .expect("could not create the generated Coq inductive type file");
    write!(f, "{}", output).expect("could not write to the generated Coq inductive type file");
    println!("Generated a construction of the inductive type at: {}-indty.v", coq_gen.name);
}
/* [[IGNORE */
}
/* IGNORE]] */
