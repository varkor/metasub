/* [[INSERT: header]] */

extern crate chrono;
extern crate regex;

use std::collections::HashMap;
use std::env;
use std::fmt;
use std::fmt::{Debug, Display};
use std::fs::File;
use std::iter;
use std::io::prelude::*;
use std::io::stdin;
use std::path::Path;

use chrono::DateTime;
use chrono::Utc;
use regex::Regex;

fn number_word(x: usize) -> &'static str {
    match x {
        0 => "zero",
        1 => "one",
        2 => "two",
        3 => "three",
        4 => "four",
        5 => "five",
        6 => "six",
        7 => "seven",
        8 => "eight",
        9 => "nine",
        _ => panic!(),
    }
}

fn char_has_case(c: char) -> bool {
    c.is_lowercase() || c.is_uppercase()
}

fn to_camel_case(s: &str) -> String {
    let re_split = Regex::new(r"[^a-zA-Z]+").unwrap();
    re_split.split(s)
            .map(|word| {
                word.chars().enumerate().map(|(i, c)| if i == 0 {
                    c.to_uppercase().collect::<String>()
                } else {
                    c.to_lowercase().collect()
                })
                .collect::<Vec<_>>()
                .concat()
            })
            .filter(|x| !x.is_empty())
            .collect::<Vec<_>>()
            .iter().fold((String::new(), None), |(acc, prev): (String, Option<&String>), next| {
                let join = if let Some(prev) = prev {
                                let l = prev.chars().last().unwrap();
                                let f = next.chars().next().unwrap();
                                !char_has_case(l) && !char_has_case(f)
                            } else { false };
                (acc + if join { "_" } else { "" } + next, Some(next))
            }).0
}

pub struct CoqGen<'a> {
    pub name: &'a str,
    pub ops: &'a Vec<(&'a str, Vec<u8>)>,
    pub metavars: &'a Vec<(&'a str, Vec<u8>)>,
}

impl<'a> CoqGen<'a> {
    pub fn gen_colimit(&self) -> String {
        format!("{}{}\n{}", self.comment(), self.header(), self.body())
    }

    fn header(&self) -> String {
        format!("\
            {}\n\
            \n\
            Local Infix \"::\" := (@cons nat).\n\
            Local Notation \"[]\" := (@nil nat) (at level 0, format \"[]\").\n\
            Local Notation \"'HSET2'\":= [HSET, HSET, has_homsets_HSET].\n\
            \n\
            {}\
        ", self.imports(false), self.preamble())
    }

    fn comment(&self) -> String {
        let now: DateTime<Utc> = Utc::now();
        format!("\
            (* Autogenerated Coq file: {} *)\n\
            \n\
        ", now.format("%Y-%m-%d %H:%M:%S"))
    }

    fn preamble(&self) -> String {
        format!("\
            Local Open Scope cat.\n\
            \n\
            Section preamble.\n\
            \n\
            {}\n\
            Local Lemma has_homsets_HSET2 : has_homsets HSET2.\n\
            Proof.\n\t\
                apply functor_category_has_homsets.\n\
            Defined.\n\
            \n\
            End preamble.\
        ", self.n_rec())
    }

    fn n_rec(&self) -> String {
        const LETTERS: [&str; 9] = ["a", "b", "c", "d", "e", "f", "g", "h", "i"];
        let n = self.ops.len();
        let vars = &LETTERS[0..n as usize];
        let ind_steps: Vec<_> = vars.iter()
                                    .map(|v| format!("induction n as [|n _]; [apply {}|].", v))
                                    .collect();
        format!("\
            Definition {n}_rec {{A : UU}} ({} : A) : stn {} -> A.\n\
            Proof.\n\t\
            induction 1 as [n p].\n\t\
            {}\n\t\
            induction (nopathsfalsetotrue p).\n\
            Defined.\
        ", vars.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(" "),
        n,
        ind_steps.join("\n\t"),
        n = number_word(n))
    }

    fn imports(&self, conservative: bool) -> String {
        let required = format!("\
            Require Import UniMath.Foundations.PartD.\
        ");
        if conservative {
            required
        } else {
            format!("\
                {}
                \n\
                Require Import UniMath.Combinatorics.StandardFiniteSets.\n\
                Require Import UniMath.Combinatorics.Lists.\n\
                \n\
                Require Import UniMath.CategoryTheory.Categories.\n\
                Require Import UniMath.CategoryTheory.functor_categories.\n\
                Require Import UniMath.CategoryTheory.categories.category_hset.\n\
                Require Import UniMath.CategoryTheory.categories.category_hset_structures.\n\
                Require Import UniMath.CategoryTheory.limits.initial.\n\
                Require Import UniMath.CategoryTheory.FunctorAlgebras.\n\
                Require Import UniMath.CategoryTheory.Monads.Monads.\n\
                \n\
                Require Import UniMath.SubstitutionSystems.Signatures.\n\
                Require Import UniMath.SubstitutionSystems.BindingSigToMonad.\n\
                Require Import UniMath.SubstitutionSystems.LiftingInitial_alt.\
            ", required)
        }
    }

    fn body(&self) -> String {
        let names = self.ops.iter().map(|x| x.0.to_string()).collect::<Vec<_>>();
        let sigs = self.ops.iter().map(|x| format!("{:?}", x.1)).collect::<Vec<_>>();
        let definitions: Vec<String> = self.ops.iter().map(|&(ref name, ref sig)| {
            let sig = format!("({} :: [])",
                            sig.iter().map(u8::to_string).collect::<Vec<_>>().join(" :: "));
            format!("Local Definition {} := {}.", name, sig)
        }).collect();

        format!("\
            Section {code}.\n\
            \n\
            {}
            \n\
            (* The signature of {name}: {{ {} }} *)\n\
            Definition {code}Sig : BindingSig :=\n\t\
                mkBindingSig (isasetstn {}) ({n}_rec {}).\n\
            \n\
            (* The signature with strength for {name} *)\n\
            Definition {code}SigWithStr : Signature HSET has_homsets_HSET _ _ :=\n\t\
                BindingSigToSignatureHSET {code}Sig.\n\
            \n\
            Let Id_H := Id_H _ has_homsets_HSET BinCoproductsHSET.\n\
            \n\
            Definition {code}Functor : functor HSET2 HSET2 := Id_H {code}SigWithStr.\n\
            \n\
            Lemma {code}Functor_Initial : Initial (FunctorAlg {code}Functor has_homsets_HSET2).\n\
            Proof.\n\t\
                apply SignatureInitialAlgebraHSET, is_omega_cocont_BindingSigToSignatureHSET.\n\
            Defined.\n\
            \n\
            Definition {code}Monad : Monad HSET := BindingSigToMonadHSET {code}Sig.\n\
            \n\
            End {code}.\
        ", definitions.join("\n"),
        sigs.join(", "),
        self.ops.len(),
        names.join(" "),
        name = self.name,
        code = to_camel_case(self.name),
        n = number_word(self.ops.len()))
    }

    fn gen_inductive_type(&self, terms: Vec<String>) -> String {
        format!("{}{}\n\n{}\n\n{}",
                self.comment(),
                self.imports(true),
                self.inductive(),
                terms.join("\n\n"))
    }

    fn inductive(&self) -> String {
        let code = to_camel_case(self.name);
        let variants = self.ops.iter().chain(self.metavars.iter()).map(|x| {
            format!("| {} : {}",
                    x.0,
                    iter::repeat(code.clone())
                         .take(x.1.len() + 1)
                         .collect::<Vec<_>>()
                         .join(" -> "))
        }).collect::<Vec<_>>().join("\n");
        format!("\
            Inductive {code} : UU :=\n\
            | var : nat -> nat -> {code}\n\
            {variants}.\
        ",
        code = code,
        variants = variants)
        // Check app (abs (var 0)) (abs (var 0)).
    }

    fn inductive_term(&self, term: Term) -> String {
        format!("\
            Check {}.\
        ", term)
    }
}

#[derive(Clone)]
struct ParseError {
    s: String,
    range: (usize, usize),
    error: String,
    hint: String,
}

impl Debug for ParseError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let hint = if self.hint.is_empty() {
            String::new()
        } else {
            format!("({})", self.hint)
        };
        let mut spaces = self.range.0;
        let (prehint, posthint): (&str, &str) = if spaces >= hint.len() + 1 {
            (&hint, "")
        } else {
            ("", &hint)
        };
        let space_offset = !prehint.is_empty() as usize;
        spaces -= prehint.len() + space_offset;
        let msg = &self.error;
        write!(f,
            "\n{start}{} (L1:{}-{}):{end}\n{}\n{start}{}{prehint}{}{posthint}{end}\n",
            msg,
            self.range.0,
            self.range.1,
            self.s,
            " ".repeat(spaces),
            (if prehint.is_empty() { String::new() } else { " ".to_string() })
                + &"^".repeat(self.range.1 - self.range.0)
                + (if posthint.is_empty() { "" } else { " " }),
            prehint = prehint,
            posthint = posthint,
            start = "\x1b[31;1m",
            end = "\x1b[0m")
    }
}

trait FailParse<T> {
    fn with_err_message(self, error: &str) -> Self;
    fn or_fail(self, error: &str) -> T;
}

impl<T> FailParse<T> for Result<T, ParseError> {
    fn with_err_message(self, error: &str) -> Self {
        if let Err(ref pe) = self {
            let mut pe = pe.clone();
            if env::var("METASUB_DEBUG").is_err() || pe.error == "<unknown parse error>" {
                pe.error = error.to_string()
            } else {
                pe.error = format!("{} | {}", pe.error, error.to_string());
            }
            Err::<T, _>(pe)
        } else {
            self
        }
    }

    fn or_fail(self, error: &str) -> T {
        self.with_err_message(error).unwrap()
    }
}

struct Operation {
    op: String,
    args: Vec<Term>,
}

impl Display for Operation {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}{}", self.op, self.args.iter().map(|arg| {
            if arg.needs_closure() {
                format!(" ({})", arg)
            } else {
                format!(" {}", arg)
            }
        }).collect::<Vec<_>>().join(""))
    }
}

struct Metavar {
    metavar: String,
    args: Vec<Term>,
}

impl Display for Metavar {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}{}", self.metavar, self.args.iter().map(|arg| {
            if arg.needs_closure() {
                format!(" ({})", arg)
            } else {
                format!(" {}", arg)
            }
        }).collect::<Vec<_>>().join(""))
    }
}

enum Term {
    Var(u8, u8),
    Op(Operation),
    Metavar(Metavar),
}

impl Term {
    fn needs_closure(&self) -> bool {
        // ...closure inside parentheses, that is.
        match self {
            Term::Var(..) => true,
            Term::Op(op) => !op.args.is_empty(),
            Term::Metavar(mv) => !mv.args.is_empty(),
        }
    }
}

impl Display for Term {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Term::Var(depth, offset) => write!(f, "var {} {}", depth, offset),
            Term::Op(op) => op.fmt(f),
            Term::Metavar(mv) => mv.fmt(f),
        }
    }
}

impl Debug for Term {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self)
    }
}

struct TermParser<'a> {
    os: String, // original string
    s: String, // current string
    pos: usize, // current position
    ops: &'a Vec<(&'a str, Vec<u8>)>, // valid operations
    metavars: &'a Vec<(&'a str, Vec<u8>)>, // metavariables
}

struct ParseContext {
    s: String,
    pos: usize,
}

impl<'a> TermParser<'a> {
    fn save_context(&self) -> ParseContext {
        ParseContext {
            s: self.s.clone(),
            pos: self.pos,
        }
    }

    fn restore_context(&mut self, ctx: ParseContext) {
        self.s = ctx.s;
        self.pos = ctx.pos;
    }

    fn error_hint(&self, hint: &str) -> ParseError {
        ParseError {
            s: self.os.clone(),
            range: (self.pos, self.pos + 1),
            error: "<unknown parse error>".to_string(),
            hint: hint.to_string(),
        }
    }

    fn error(&self) -> ParseError {
        self.error_hint("")
    }

    fn eat_op_or_metavar(&mut self, vars: HashMap<String, (u8, u8)>, level: u8)
        -> Result<Term, ParseError> {
        let prev_ctx = self.save_context();
        let eaten_op = self.eat_op(vars.clone(), level);
        let after_ctx = self.save_context();
        if eaten_op.is_err() {
            self.restore_context(prev_ctx);
            let mut progressed = false;
            let eaten_metavar = self.eat_metavar(vars, level, &mut progressed);
            if progressed {
                return eaten_metavar;
            }
            self.restore_context(after_ctx);
        }
        eaten_op
    }

    fn eat_metavar(&mut self, vars: HashMap<String, (u8, u8)>, level: u8, progressed: &mut bool)
        -> Result<Term, ParseError> {
        let (name, arity) = self.eat_name(true).with_err_message("couldn't eat metavar name")?;
        *progressed = true;
        self.eat_str_ignore(r"\[")?;
        let mut args = vec![];
        for (i, &num_binders) in arity.iter().enumerate() {
            let eat_arg = self.eat_argument(false, num_binders, vars.clone(), level);
            if eat_arg.is_err() {
                let err_hint = self.error_hint(
                    format!("expected {} input{}",
                        arity.len(),
                        if arity.len() != 1 { 's'.to_string() } else { String::new() }).as_str()
                );
                Err::<(), ParseError>(err_hint).with_err_message("too few inputs for arity")?;
            }
            args.push(eat_arg?);

            if i < arity.len() - 1 {
                self.eat_str_ignore(", ")?;
            }
        }
        self.eat_str_ignore(r"\]")?;
        Ok(Term::Metavar(Metavar {
            metavar: name,
            args,
        }))
    }

    fn eat_op(&mut self, vars: HashMap<String, (u8, u8)>, level: u8)
        -> Result<Term, ParseError> {
        let name_result = self.eat_name(false);
        if let Err(e) = name_result {
            return if vars.len() > 0 {
                // TODO: Validate var
                let var = self.eat_var().with_err_message("didn't find var")?;
                if let Some(&(level, offset)) = vars.get(&var) {
                    Ok(Term::Var(level, offset))
                } else {
                    self.pos -= var.len();
                    let err_hint =
                        if let Some(ex_var) = vars.iter().next().map(|(v, _)| v) {
                        format!("maybe you meant `{}`", ex_var)
                    } else {
                        "no variables are bound".to_string()
                    };
                    Err::<Term, ParseError>(self.error_hint(&err_hint))
                        .with_err_message("use of unbound variable")
                }
            } else {
                Err(e)
            }
        }
        let (name, arity) = name_result.with_err_message("couldn't unwrap name_result")?;
        let mut args = vec![];
        for num_binders in arity {
            self.eat_space()?;
            args.push(self.eat_argument(true, num_binders, vars.clone(), level)
                          .with_err_message("didn't find argument")?);
        }
        Ok(Term::Op(Operation {
            op: name,
            args,
        }))
    }

    fn eat_str(&mut self, s: &str) -> Result<String, ParseError> {
        let re_str = Regex::new(&format!("^{}", s)).expect("invalid str for regex");
        let s = self.s.clone();
        if let Some(m) = re_str.find(&s) {
            self.s = re_str.replace(&self.s, "").to_string();
            let mstr = m.as_str().to_string();
            self.pos += mstr.len();
            return Ok(mstr);
        }
        Err(self.error())
    }

    fn eat_str_ignore(&mut self, s: &str) -> Result<(), ParseError> {
        self.eat_str(s).with_err_message(&format!("couldn't eat `{}`", s))?;
        Ok(())
    }

    fn eat_space(&mut self) -> Result<(), ParseError> {
        self.eat_str_ignore(" ").with_err_message("couldn't eat <space>")
    }

    fn eat_open(&mut self) -> Result<(), ParseError> {
        self.eat_str_ignore(r"\(").with_err_message("couldn't eat (")
    }

    fn eat_close(&mut self) -> Result<(), ParseError> {
        self.eat_str_ignore(r"\)").with_err_message("couldn't eat )")
    }

    fn eat_name(&mut self, metavar: bool) -> Result<(String, Vec<u8>), ParseError> {
        let re_name = if metavar {
            Regex::new(r"^[A-Z][A-Z']*").unwrap()
        } else {
            Regex::new(r"^[a-z][a-z']*").unwrap()
        };
        let s = self.s.clone();
        if let Some(name) = re_name.find(&s) {
            for &(ref on, ref oa) in if metavar { self.metavars } else { self.ops } {
                if *on == name.as_str() {
                    self.s = re_name.replace(&self.s, "").to_string();
                    self.pos += on.len();
                    return Ok((on.to_string(), oa.clone()));
                }
            }
        }
        Err(self.error()).with_err_message("could not eat name")
    }

    fn eat_argument(&mut self,
                    require_parentheses: bool,
                    binders: u8,
                    mut vars: HashMap<String, (u8, u8)>,
                    level: u8) -> Result<Term, ParseError> {
        if require_parentheses {
            self.eat_open().with_err_message("didn't find `(`")?;
        }
        for i in 0..binders {
            // TODO: Check validity of binders
            vars.insert(self.eat_var()?, (level, i));
            self.eat_space().with_err_message("didn't find space")?;
        }
        if binders > 0 {
            let eat_arrow = self.eat_str("-> ");
            if let Err(_) = eat_arrow {
                if Regex::new(&format!("^>")).unwrap().is_match(&self.s) ||
                   Regex::new(&format!("^-")).unwrap().is_match(&self.s) {
                    Err::<(), ParseError>(self.error_hint("you probably meant `->`"))
                        .with_err_message("unexpected symbol `>`")?;
                } if let Ok(var) = self.eat_var() {
                    self.pos -= var.len();
                    let err_hint = self.error_hint(
                        format!("expected only {} argument{}",
                            binders,
                            if binders != 1 { 's'.to_string() } else { String::new() })
                            .as_str()
                    );
                    Err::<(), ParseError>(err_hint)
                        .with_err_message("wrong number of binders for arity")?;
                } else {
                    eat_arrow.with_err_message("didn't find arrow")?;
                }
            }
        }
        let op = self.eat_op_or_metavar(vars.clone(), level + 1)
                     .with_err_message("didn't find op")?;
        if require_parentheses {
            self.eat_close().with_err_message("didn't find `)`")?;
        }
        Ok(op)
    }

    fn eat_var(&mut self) -> Result<String, ParseError> {
        Ok(self.eat_str("[a-z]+")?)
    }
}

// We only run `main` in the second stage of our pipeline, so it will be
// marked as unused by the compiler. We just want it to compile.
#[allow(dead_code)] /* [[IGNORE]] */
fn main() {
    let inferred_name: &str;
    inferred_name = "signatures"; /* [[INSERT: inferred_name]] */
    // Input
    let args: Vec<String> = env::args().collect();
    let filename = args.get(1).expect("pass a filename as an argument");
    let interactive = filename == "-i" || filename == "--interactive";
    let mut terms: Vec<String> = vec![];
    if !interactive {
        // Load terms from a file.
        let mut f = File::open(filename).expect("the file could not be found");
        let mut contents = String::new();
        f.read_to_string(&mut contents).expect("could not read the file");
        let lines = contents.split("\n");
        let re_comment = Regex::new(r"^#.*$").unwrap();
        terms = lines.filter_map(|s| {
            let s = s.trim();
            if s.is_empty() || re_comment.is_match(s) {
                return None;
            }
            Some(s.to_string())
        }).collect();
    }

    // The operations as a list of (name, binding arities) pairs.
    let ops: Vec<(&str, Vec<u8>)> = vec![
        /* [[INSERT: ops]] */
    ];
    let gen_vars: Vec<&str> = vec![
        /* [[INSERT: gen_vars]] */
    ];
    let metavars: Vec<(&str, Vec<u8>)> = vec![
        /* [[INSERT: metavars]] */
    ];

    let coq_gen = CoqGen { name: inferred_name, ops: &ops, metavars: &metavars };

    let check_term = |term: String| {
        let mut term_parser = TermParser {
            os: term.clone(),
            s: term.clone(),
            pos: 0,
            ops: &ops,
            metavars: &metavars,
        };
        let vars: HashMap<String, (u8, u8)> = gen_vars.iter().enumerate().map(|(i, v)| {
            (v.to_string(), (0, i as u8))
        }).collect();
        let term = term_parser.eat_op_or_metavar(vars, 0).expect("term was not valid!");
        println!("Term was syntactically correct.");
        coq_gen.inductive_term(term)
    };

    let mut verified_terms = vec![];
    if interactive {
        // Interactive mode.
        loop {
            println!("Please enter a term to type check:");
            let mut term = String::new();
            let bytes = stdin().read_line(&mut term).expect("Error reading input string");
            if bytes == 0 {
                // EOF
                break;
            }
            term.pop(); // Remove \n
            verified_terms.push(check_term(term));
        }
    } else {
        for term in terms {
            verified_terms.push(check_term(term));
        }
    }

    // Inductive type file
    let output = format!("{}\n", coq_gen.gen_inductive_type(verified_terms));
    let mut f = File::create(Path::new(&format!("out/{}-inductive-type", coq_gen.name))
                     .with_extension("v"))
                     .expect("could not create the generated Coq inductive type file");
    write!(f, "{}", output).expect("could not write to the generated Coq inductive type file");
    println!("Generated a construction of the inductive type at: {}-inductive-type.v",
             coq_gen.name);
}
